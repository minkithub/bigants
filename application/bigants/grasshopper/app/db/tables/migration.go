// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
	"time"
)

// MigrationRow represents a row for table "migration"
type MigrationRow struct {
	MigrationData
}

type MigrationData struct {
	Version string     `json:"version"`
	Created *time.Time `json:"created"`
}

func NewMigrationRow(version string, created *time.Time) *MigrationRow {
	return &MigrationRow{MigrationData{version, created}}
}

func NewMigrationRows(data ...MigrationData) MigrationRows {
	rows := make(MigrationRows, len(data))
	for i, d := range data {
		rows[i] = &MigrationRow{d}
	}
	return rows
}

// GetVersion gets value of column "version" from "migration" row
func (r *MigrationRow) GetVersion() string { return r.MigrationData.Version }

// SetVersion sets value of column "version" in "migration" row
func (r *MigrationRow) SetVersion(version string) { r.MigrationData.Version = version }

// GetCreated gets value of column "created" from "migration" row
func (r *MigrationRow) GetCreated() time.Time { return *r.MigrationData.Created }

// SetCreated sets value of column "created" in "migration" row
func (r *MigrationRow) SetCreated(created time.Time) { r.MigrationData.Created = &created }

// ClearCreated sets value of column "created" null in "migration" row
func (r *MigrationRow) ClearCreated() { r.MigrationData.Created = nil }

// HasValidCreated checks to value of column "created" is not null
func (r *MigrationRow) HasValidCreated() bool { return r.MigrationData.Created != nil }

// MigrationVersion represents key defined by PRIMARY KEY constraint "migration_pkey" for table "migration"
type MigrationVersion struct {
	Version string `json:"version"`
}

func (r *MigrationRow) KeyVersion() MigrationVersion {
	return MigrationVersion{r.GetVersion()}
}

// MigrationRows represents multiple rows for table "migration"
type MigrationRows []*MigrationRow

func (rs MigrationRows) KeyVersion() (keys Keys) {
	keys = make(Keys, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyVersion()
	}
	return keys
}

// NewMigrationTable(h SQLHandle) creates new MigrationTable
func NewMigrationTable(h SQLHandle) *MigrationTable {
	return &MigrationTable{h}
}

// MigrationTable provides access methods for table "migration"
type MigrationTable struct {
	h SQLHandle
}

func (t *MigrationTable) Find(ctx context.Context, filter MigrationValues) (MigrationRows, error) {
	return FindMigrationRows(ctx, t.h, filter)
}

func (t *MigrationTable) Count(ctx context.Context, filter MigrationValues) (int, error) {
	return CountMigrationRows(ctx, t.h, filter)
}

func (t *MigrationTable) Update(ctx context.Context, changeset, filter MigrationValues) (int64, error) {
	return UpdateMigrationRows(ctx, t.h, changeset, filter)
}

func (t *MigrationTable) Insert(ctx context.Context, rows ...*MigrationRow) (int, error) {
	return InsertReturningMigrationRows(ctx, t.h, rows...)
}

func (t *MigrationTable) Delete(ctx context.Context, filter MigrationValues) (int64, error) {
	return DeleteMigrationRows(ctx, t.h, filter)
}

func (t *MigrationTable) Save(ctx context.Context, rows ...*MigrationRow) error {
	return SaveReturningMigrationRows(ctx, t.h, rows...)
}

func (t *MigrationTable) GetByVersion(ctx context.Context, keys ...interface{}) (MigrationRows, error) {
	return GetMigrationRowsByVersion(ctx, t.h, keys...)
}

func (t *MigrationTable) UpdateByVersion(ctx context.Context, changeset MigrationValues, keys ...interface{}) (int64, error) {
	return UpdateMigrationRowsByVersion(ctx, t.h, changeset, keys...)
}

func (t *MigrationTable) DeleteByVersion(ctx context.Context, keys ...interface{}) (int64, error) {
	return DeleteMigrationRowsByVersion(ctx, t.h, keys...)
}

type MigrationValues struct {
	Version *string    `json:"version"`
	Created *time.Time `json:"created"`
}

// InsertMigrationRows inserts the rows into table "migration"
func InsertMigrationRows(ctx context.Context, db SQLHandle, rows ...*MigrationRow) (numRows int64, err error) {
	if len(rows) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertMigrationRows, rows)
	if err != nil {
		return numRows, formatError("InsertMigrationRows", err)
	}
	return numRows, nil
}

// InsertReturningMigrationRows inserts the rows into table "migration" and returns the rows.
func InsertReturningMigrationRows(ctx context.Context, db SQLHandle, inputs ...*MigrationRow) (numRows int, err error) {
	if len(inputs) == 0 {
		return 0, nil
	}
	rows := MigrationRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningMigrationRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningMigrationRows", err)
	}
	return numRows, nil
}

// FindMigrationRows finds the rows matching the condition from table "migration"
func FindMigrationRows(ctx context.Context, db SQLHandle, cond MigrationValues) (rows MigrationRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindMigrationRows, cond); err != nil {
		return nil, formatError("FindMigrationRows", err)
	}
	return rows, nil
}

// DeleteMigrationRows deletes the rows matching the condition from table "migration"
func DeleteMigrationRows(ctx context.Context, db SQLHandle, cond MigrationValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeleteMigrationRows, cond); err != nil {
		return numRows, formatError("DeleteMigrationRows", err)
	}
	return numRows, nil
}

func UpdateMigrationRows(ctx context.Context, db SQLHandle, changeset, filter MigrationValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdateMigrationRows, changeset, filter); err != nil {
		return numRows, formatError("UpdateMigrationRows", err)
	}
	return numRows, nil
}

// CountMigrationRows counts the number of rows matching the condition from table "migration"
func CountMigrationRows(ctx context.Context, db SQLHandle, cond MigrationValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountMigrationRows, cond); err != nil {
		return 0, formatError("CountMigrationRows", err)
	}
	return count, nil
}

// SaveMigrationRows upserts the given rows for table "migration" checking uniqueness by contstraint "migration_pkey"
func SaveMigrationRows(ctx context.Context, db SQLHandle, rows ...*MigrationRow) (err error) {
	if len(rows) == 0 {
		return nil
	}
	_, err = execWithJSONArgs(ctx, db, SQLSaveMigrationRows, rows)
	if err != nil {
		return formatError("SaveMigrationRows", err)
	}
	return nil
}

// SaveReturningMigrationRows upserts the given rows for table "migration" checking uniqueness by contstraint "migration_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningMigrationRows(ctx context.Context, db SQLHandle, inputs ...*MigrationRow) (err error) {
	if len(inputs) == 0 {
		return nil
	}
	rows := MigrationRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningMigrationRows, rows)
	if err != nil {
		return formatError("SaveReturningMigrationRows", err)
	}
	return nil
}

// GetMigrationRowsByVersion gets matching rows for given Version keys from table "migration"
func GetMigrationRowsByVersion(ctx context.Context, db SQLHandle, keys ...interface{}) (rows MigrationRows, err error) {
	if len(keys) == 0 {
		return nil, nil
	}
	rows = make(MigrationRows, 0, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLGetMigrationRowsByVersion, Keys(keys)); err != nil {
		return nil, formatError("GetMigrationRowsByVersion", err)
	}
	return rows, nil
}

// DeleteMigrationRowsByVersion deletes matching rows by MigrationVersion keys from table "migration"
func DeleteMigrationRowsByVersion(ctx context.Context, db SQLHandle, keys ...interface{}) (numRows int64, err error) {
	if len(keys) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLDeleteMigrationRowsByVersion, keys)
	if err != nil {
		return numRows, formatError("DeleteMigrationRowsByVersion", err)
	}
	return numRows, nil
}

// UpdateMigrationRowsByVersion deletes matching rows by MigrationVersion keys from table "migration"
func UpdateMigrationRowsByVersion(ctx context.Context, db SQLHandle, changeset MigrationValues, keys ...interface{}) (numRows int64, err error) {
	if len(keys) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdateMigrationRowsByVersion, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateMigrationRowsByVersion", err)
	}
	return numRows, nil
}

// ReceiveRow returns all pointers of the column values for scanning
func (r *MigrationRow) ReceiveRow() []interface{} {
	return []interface{}{&r.MigrationData.Version, &r.MigrationData.Created}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *MigrationRows) ReceiveRows(i int) []interface{} {
	if len(*rs) <= i {
		*rs = append(*rs, new(MigrationRow))
	} else if (*rs)[i] == nil {
		(*rs)[i] = new(MigrationRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *MigrationRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.MigrationData)
}

var (
	SQLFindMigrationRows = `
		WITH __f AS (SELECT "version", "created" FROM json_populate_record(null::"gh"."migration", $1))
		SELECT __t.version, __t.created
		FROM "gh"."migration" AS __t
		WHERE ((SELECT __f."version" IS NULL FROM __f) OR (SELECT __f."version" = __t."version" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))`
	SQLCountMigrationRows = `
		WITH __f AS (SELECT "version", "created" FROM json_populate_record(null::"gh"."migration", $1))
		SELECT count(*) FROM "gh"."migration" AS __t
		WHERE ((SELECT __f."version" IS NULL FROM __f) OR (SELECT __f."version" = __t."version" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))`
	SQLReturningMigrationRows = `
		RETURNING "version", "created"`
	SQLInsertMigrationRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."migration", $1))
		INSERT INTO "gh"."migration" AS __t ("version", "created")
		SELECT 
			__v."version", 
			COALESCE(__v."created", now()) FROM __v`
	SQLInsertReturningMigrationRows = SQLInsertMigrationRows + SQLReturningMigrationRows
	SQLDeleteMigrationRows          = `
		DELETE FROM "gh"."migration" AS __t
		WHERE TRUE
			AND (($1::json->>'version' IS NULL) OR CAST($1::json->>'version' AS text) = __t."version")
			AND (($1::json->>'created' IS NULL) OR CAST($1::json->>'created' AS timestamp with time zone) = __t."created")`
	SQLDeleteReturningMigrationRows = SQLDeleteMigrationRows + SQLReturningMigrationRows
	SQLUpdateMigrationRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"gh"."migration", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"gh"."migration", $2))
		UPDATE "gh"."migration" AS __t
		SET ("version", "created") = (SELECT 
			COALESCE(__v."version", __t."version"), 
			COALESCE(__v."created", __t."created") FROM __v)
		WHERE ((SELECT __f."version" IS NULL FROM __f) OR (SELECT __f."version" = __t."version" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))`
	SQLUpdateReturningMigrationRows = SQLUpdateMigrationRows + SQLReturningMigrationRows
	SQLReplaceMigrationRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."migration", $1))
		UPDATE "gh"."migration" AS __t
			SET ("version", "created") = (SELECT 
				COALESCE(__v."version", __t."version"), 
				COALESCE(__v."created", __t."created")
			FROM __v WHERE __v."version" = __t."version")
		FROM __v WHERE __v."version" = __t."version"`
	SQLReplaceReturningMigrationRows = SQLReplaceMigrationRows + SQLReturningMigrationRows
	SQLSaveMigrationRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."migration", $1))
		INSERT INTO "gh"."migration" AS __t ("version", "created")
		SELECT 
			__v."version", 
			COALESCE(__v."created", now()) FROM __v
		ON CONFLICT ("version") DO UPDATE
		SET ("version", "created") = (
			SELECT "version", "created" FROM __v
			WHERE __v."version" = __t."version"
		)`
	SQLSaveReturningMigrationRows = SQLSaveMigrationRows + SQLReturningMigrationRows
	SQLGetMigrationRowsByVersion  = `
		WITH __key AS (SELECT DISTINCT "version" FROM json_populate_recordset(null::"gh"."migration", $1))
		SELECT "version", "created"
		FROM __key JOIN "gh"."migration" AS __t USING ("version")`
	SQLUpdateMigrationRowsByVersion = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"gh"."migration", $1)),
		  __key AS (SELECT version FROM json_populate_recordset(null::"gh"."migration", $2))
		UPDATE "gh"."migration" AS __t
		SET ("version", "created") = (SELECT
			COALESCE(__v."version", __t."version"), 
			COALESCE(__v."created", __t."created")
		FROM __v)
		FROM __key WHERE (__key."version" = __t."version")`
	SQLDeleteMigrationRowsByVersion = `
		WITH __key AS (SELECT version FROM json_populate_recordset(null::"gh"."migration", $1))
		DELETE FROM "gh"."migration" AS __t USING __key WHERE (__key."version" = __t."version")`
	SQLDeleteReturningMigrationRowsByVersion = SQLDeleteMigrationRowsByVersion + SQLReturningMigrationRows
)
