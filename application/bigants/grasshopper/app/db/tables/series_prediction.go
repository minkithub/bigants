// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
	"time"
)

// SeriesPredictionRow represents a row for table "series_prediction"
type SeriesPredictionRow struct {
	SeriesPredictionData
}

type SeriesPredictionData struct {
	StockPredictionID string    `json:"stock_prediction_id"`
	Source            string    `json:"source"`
	Created           time.Time `json:"created"`
	Mae               float64   `json:"mae"`
	Mape              float64   `json:"mape"`
}

func NewSeriesPredictionRow(stockPredictionID string, source string, created time.Time, mae float64, mape float64) *SeriesPredictionRow {
	return &SeriesPredictionRow{SeriesPredictionData{stockPredictionID, source, created, mae, mape}}
}

func NewSeriesPredictionRows(data ...SeriesPredictionData) SeriesPredictionRows {
	rows := make(SeriesPredictionRows, len(data))
	for i, d := range data {
		rows[i] = &SeriesPredictionRow{d}
	}
	return rows
}

// GetStockPredictionID gets value of column "stock_prediction_id" from "series_prediction" row
func (r *SeriesPredictionRow) GetStockPredictionID() string {
	return r.SeriesPredictionData.StockPredictionID
}

// SetStockPredictionID sets value of column "stock_prediction_id" in "series_prediction" row
func (r *SeriesPredictionRow) SetStockPredictionID(stockPredictionID string) {
	r.SeriesPredictionData.StockPredictionID = stockPredictionID
}

// GetSource gets value of column "source" from "series_prediction" row
func (r *SeriesPredictionRow) GetSource() string { return r.SeriesPredictionData.Source }

// SetSource sets value of column "source" in "series_prediction" row
func (r *SeriesPredictionRow) SetSource(source string) { r.SeriesPredictionData.Source = source }

// GetCreated gets value of column "created" from "series_prediction" row
func (r *SeriesPredictionRow) GetCreated() time.Time { return r.SeriesPredictionData.Created }

// SetCreated sets value of column "created" in "series_prediction" row
func (r *SeriesPredictionRow) SetCreated(created time.Time) { r.SeriesPredictionData.Created = created }

// GetMae gets value of column "mae" from "series_prediction" row
func (r *SeriesPredictionRow) GetMae() float64 { return r.SeriesPredictionData.Mae }

// SetMae sets value of column "mae" in "series_prediction" row
func (r *SeriesPredictionRow) SetMae(mae float64) { r.SeriesPredictionData.Mae = mae }

// GetMape gets value of column "mape" from "series_prediction" row
func (r *SeriesPredictionRow) GetMape() float64 { return r.SeriesPredictionData.Mape }

// SetMape sets value of column "mape" in "series_prediction" row
func (r *SeriesPredictionRow) SetMape(mape float64) { r.SeriesPredictionData.Mape = mape }

// SeriesPredictionRows represents multiple rows for table "series_prediction"
type SeriesPredictionRows []*SeriesPredictionRow

func (r *SeriesPredictionRow) RefStockPredictionID() StockPredictionID {
	return StockPredictionID{r.GetStockPredictionID()}
}

func (rs SeriesPredictionRows) RefStockPredictionID() (keys Keys) {
	keys = make(Keys, len(rs))
	for i, r := range rs {
		keys[i] = r.RefStockPredictionID()
	}
	return keys
}

// NewSeriesPredictionTable(h SQLHandle) creates new SeriesPredictionTable
func NewSeriesPredictionTable(h SQLHandle) *SeriesPredictionTable {
	return &SeriesPredictionTable{h}
}

// SeriesPredictionTable provides access methods for table "series_prediction"
type SeriesPredictionTable struct {
	h SQLHandle
}

func (t *SeriesPredictionTable) Find(ctx context.Context, filter SeriesPredictionValues) (SeriesPredictionRows, error) {
	return FindSeriesPredictionRows(ctx, t.h, filter)
}

func (t *SeriesPredictionTable) Count(ctx context.Context, filter SeriesPredictionValues) (int, error) {
	return CountSeriesPredictionRows(ctx, t.h, filter)
}

func (t *SeriesPredictionTable) Update(ctx context.Context, changeset, filter SeriesPredictionValues) (int64, error) {
	return UpdateSeriesPredictionRows(ctx, t.h, changeset, filter)
}

func (t *SeriesPredictionTable) Insert(ctx context.Context, rows ...*SeriesPredictionRow) (int, error) {
	return InsertReturningSeriesPredictionRows(ctx, t.h, rows...)
}

func (t *SeriesPredictionTable) Delete(ctx context.Context, filter SeriesPredictionValues) (int64, error) {
	return DeleteSeriesPredictionRows(ctx, t.h, filter)
}

type SeriesPredictionValues struct {
	StockPredictionID *string    `json:"stock_prediction_id"`
	Source            *string    `json:"source"`
	Created           *time.Time `json:"created"`
	Mae               *float64   `json:"mae"`
	Mape              *float64   `json:"mape"`
}

// InsertSeriesPredictionRows inserts the rows into table "series_prediction"
func InsertSeriesPredictionRows(ctx context.Context, db SQLHandle, rows ...*SeriesPredictionRow) (numRows int64, err error) {
	if len(rows) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertSeriesPredictionRows, rows)
	if err != nil {
		return numRows, formatError("InsertSeriesPredictionRows", err)
	}
	return numRows, nil
}

// InsertReturningSeriesPredictionRows inserts the rows into table "series_prediction" and returns the rows.
func InsertReturningSeriesPredictionRows(ctx context.Context, db SQLHandle, inputs ...*SeriesPredictionRow) (numRows int, err error) {
	if len(inputs) == 0 {
		return 0, nil
	}
	rows := SeriesPredictionRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningSeriesPredictionRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningSeriesPredictionRows", err)
	}
	return numRows, nil
}

// FindSeriesPredictionRows finds the rows matching the condition from table "series_prediction"
func FindSeriesPredictionRows(ctx context.Context, db SQLHandle, cond SeriesPredictionValues) (rows SeriesPredictionRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindSeriesPredictionRows, cond); err != nil {
		return nil, formatError("FindSeriesPredictionRows", err)
	}
	return rows, nil
}

// DeleteSeriesPredictionRows deletes the rows matching the condition from table "series_prediction"
func DeleteSeriesPredictionRows(ctx context.Context, db SQLHandle, cond SeriesPredictionValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeleteSeriesPredictionRows, cond); err != nil {
		return numRows, formatError("DeleteSeriesPredictionRows", err)
	}
	return numRows, nil
}

func UpdateSeriesPredictionRows(ctx context.Context, db SQLHandle, changeset, filter SeriesPredictionValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdateSeriesPredictionRows, changeset, filter); err != nil {
		return numRows, formatError("UpdateSeriesPredictionRows", err)
	}
	return numRows, nil
}

// CountSeriesPredictionRows counts the number of rows matching the condition from table "series_prediction"
func CountSeriesPredictionRows(ctx context.Context, db SQLHandle, cond SeriesPredictionValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountSeriesPredictionRows, cond); err != nil {
		return 0, formatError("CountSeriesPredictionRows", err)
	}
	return count, nil
}

// ReceiveRow returns all pointers of the column values for scanning
func (r *SeriesPredictionRow) ReceiveRow() []interface{} {
	return []interface{}{&r.SeriesPredictionData.StockPredictionID, &r.SeriesPredictionData.Source, &r.SeriesPredictionData.Created, &r.SeriesPredictionData.Mae, &r.SeriesPredictionData.Mape}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *SeriesPredictionRows) ReceiveRows(i int) []interface{} {
	if len(*rs) <= i {
		*rs = append(*rs, new(SeriesPredictionRow))
	} else if (*rs)[i] == nil {
		(*rs)[i] = new(SeriesPredictionRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *SeriesPredictionRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.SeriesPredictionData)
}

var (
	SQLFindSeriesPredictionRows = `
		WITH __f AS (SELECT "stock_prediction_id", "source", "created", "mae", "mape" FROM json_populate_record(null::"gh"."series_prediction", $1))
		SELECT __t.stock_prediction_id, __t.source, __t.created, __t.mae, __t.mape
		FROM "gh"."series_prediction" AS __t
		WHERE ((SELECT __f."stock_prediction_id" IS NULL FROM __f) OR (SELECT __f."stock_prediction_id" = __t."stock_prediction_id" FROM __f))
			AND ((SELECT __f."source" IS NULL FROM __f) OR (SELECT __f."source" = __t."source" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."mae" IS NULL FROM __f) OR (SELECT __f."mae" = __t."mae" FROM __f))
			AND ((SELECT __f."mape" IS NULL FROM __f) OR (SELECT __f."mape" = __t."mape" FROM __f))`
	SQLCountSeriesPredictionRows = `
		WITH __f AS (SELECT "stock_prediction_id", "source", "created", "mae", "mape" FROM json_populate_record(null::"gh"."series_prediction", $1))
		SELECT count(*) FROM "gh"."series_prediction" AS __t
		WHERE ((SELECT __f."stock_prediction_id" IS NULL FROM __f) OR (SELECT __f."stock_prediction_id" = __t."stock_prediction_id" FROM __f))
			AND ((SELECT __f."source" IS NULL FROM __f) OR (SELECT __f."source" = __t."source" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."mae" IS NULL FROM __f) OR (SELECT __f."mae" = __t."mae" FROM __f))
			AND ((SELECT __f."mape" IS NULL FROM __f) OR (SELECT __f."mape" = __t."mape" FROM __f))`
	SQLReturningSeriesPredictionRows = `
		RETURNING "stock_prediction_id", "source", "created", "mae", "mape"`
	SQLInsertSeriesPredictionRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."series_prediction", $1))
		INSERT INTO "gh"."series_prediction" AS __t ("stock_prediction_id", "source", "created", "mae", "mape")
		SELECT 
			__v."stock_prediction_id", 
			__v."source", 
			__v."created", 
			__v."mae", 
			__v."mape" FROM __v`
	SQLInsertReturningSeriesPredictionRows = SQLInsertSeriesPredictionRows + SQLReturningSeriesPredictionRows
	SQLDeleteSeriesPredictionRows          = `
		DELETE FROM "gh"."series_prediction" AS __t
		WHERE TRUE
			AND (($1::json->>'stock_prediction_id' IS NULL) OR CAST($1::json->>'stock_prediction_id' AS uuid) = __t."stock_prediction_id")
			AND (($1::json->>'source' IS NULL) OR CAST($1::json->>'source' AS character varying) = __t."source")
			AND (($1::json->>'created' IS NULL) OR CAST($1::json->>'created' AS timestamp with time zone) = __t."created")
			AND (($1::json->>'mae' IS NULL) OR CAST($1::json->>'mae' AS numeric) = __t."mae")
			AND (($1::json->>'mape' IS NULL) OR CAST($1::json->>'mape' AS numeric) = __t."mape")`
	SQLDeleteReturningSeriesPredictionRows = SQLDeleteSeriesPredictionRows + SQLReturningSeriesPredictionRows
	SQLUpdateSeriesPredictionRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"gh"."series_prediction", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"gh"."series_prediction", $2))
		UPDATE "gh"."series_prediction" AS __t
		SET ("stock_prediction_id", "source", "created", "mae", "mape") = (SELECT 
			COALESCE(__v."stock_prediction_id", __t."stock_prediction_id"), 
			COALESCE(__v."source", __t."source"), 
			COALESCE(__v."created", __t."created"), 
			COALESCE(__v."mae", __t."mae"), 
			COALESCE(__v."mape", __t."mape") FROM __v)
		WHERE ((SELECT __f."stock_prediction_id" IS NULL FROM __f) OR (SELECT __f."stock_prediction_id" = __t."stock_prediction_id" FROM __f))
			AND ((SELECT __f."source" IS NULL FROM __f) OR (SELECT __f."source" = __t."source" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."mae" IS NULL FROM __f) OR (SELECT __f."mae" = __t."mae" FROM __f))
			AND ((SELECT __f."mape" IS NULL FROM __f) OR (SELECT __f."mape" = __t."mape" FROM __f))`
	SQLUpdateReturningSeriesPredictionRows = SQLUpdateSeriesPredictionRows + SQLReturningSeriesPredictionRows
)
