// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
	"time"
)

// StockPredictionRow represents a row for table "stock_prediction"
type StockPredictionRow struct {
	StockPredictionData
}

type StockPredictionData struct {
	ID          string    `json:"id"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	StockCode   string    `json:"stock_code"`
	Created     time.Time `json:"created"`
	RequesterID *string   `json:"requester_id"`
}

func NewStockPredictionRow(id string, startDate time.Time, endDate time.Time, stockCode string, created time.Time, requesterID *string) *StockPredictionRow {
	return &StockPredictionRow{StockPredictionData{id, startDate, endDate, stockCode, created, requesterID}}
}

func NewStockPredictionRows(data ...StockPredictionData) StockPredictionRows {
	rows := make(StockPredictionRows, len(data))
	for i, d := range data {
		rows[i] = &StockPredictionRow{d}
	}
	return rows
}

// GetID gets value of column "id" from "stock_prediction" row
func (r *StockPredictionRow) GetID() string { return r.StockPredictionData.ID }

// SetID sets value of column "id" in "stock_prediction" row
func (r *StockPredictionRow) SetID(id string) { r.StockPredictionData.ID = id }

// GetStartDate gets value of column "start_date" from "stock_prediction" row
func (r *StockPredictionRow) GetStartDate() time.Time { return r.StockPredictionData.StartDate }

// SetStartDate sets value of column "start_date" in "stock_prediction" row
func (r *StockPredictionRow) SetStartDate(startDate time.Time) {
	r.StockPredictionData.StartDate = startDate
}

// GetEndDate gets value of column "end_date" from "stock_prediction" row
func (r *StockPredictionRow) GetEndDate() time.Time { return r.StockPredictionData.EndDate }

// SetEndDate sets value of column "end_date" in "stock_prediction" row
func (r *StockPredictionRow) SetEndDate(endDate time.Time) { r.StockPredictionData.EndDate = endDate }

// GetStockCode gets value of column "stock_code" from "stock_prediction" row
func (r *StockPredictionRow) GetStockCode() string { return r.StockPredictionData.StockCode }

// SetStockCode sets value of column "stock_code" in "stock_prediction" row
func (r *StockPredictionRow) SetStockCode(stockCode string) {
	r.StockPredictionData.StockCode = stockCode
}

// GetCreated gets value of column "created" from "stock_prediction" row
func (r *StockPredictionRow) GetCreated() time.Time { return r.StockPredictionData.Created }

// SetCreated sets value of column "created" in "stock_prediction" row
func (r *StockPredictionRow) SetCreated(created time.Time) { r.StockPredictionData.Created = created }

// GetRequesterID gets value of column "requester_id" from "stock_prediction" row
func (r *StockPredictionRow) GetRequesterID() string { return *r.StockPredictionData.RequesterID }

// SetRequesterID sets value of column "requester_id" in "stock_prediction" row
func (r *StockPredictionRow) SetRequesterID(requesterID string) {
	r.StockPredictionData.RequesterID = &requesterID
}

// ClearRequesterID sets value of column "requester_id" null in "stock_prediction" row
func (r *StockPredictionRow) ClearRequesterID() { r.StockPredictionData.RequesterID = nil }

// HasValidRequesterID checks to value of column "requester_id" is not null
func (r *StockPredictionRow) HasValidRequesterID() bool {
	return r.StockPredictionData.RequesterID != nil
}

// StockPredictionID represents key defined by PRIMARY KEY constraint "stock_prediction_pkey" for table "stock_prediction"
type StockPredictionID struct {
	ID string `json:"id"`
}

func (r *StockPredictionRow) KeyID() StockPredictionID {
	return StockPredictionID{r.GetID()}
}

// StockPredictionRows represents multiple rows for table "stock_prediction"
type StockPredictionRows []*StockPredictionRow

func (rs StockPredictionRows) KeyID() (keys Keys) {
	keys = make(Keys, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyID()
	}
	return keys
}

func (r *StockPredictionRow) RefRequesterID() UserID {
	return UserID{r.GetRequesterID()}
}

func (rs StockPredictionRows) RefRequesterID() (keys Keys) {
	keys = make(Keys, len(rs))
	for i, r := range rs {
		if !r.HasValidRequesterID() {
			continue
		}
		keys[i] = r.RefRequesterID()
	}
	return keys
}

// NewStockPredictionTable(h SQLHandle) creates new StockPredictionTable
func NewStockPredictionTable(h SQLHandle) *StockPredictionTable {
	return &StockPredictionTable{h}
}

// StockPredictionTable provides access methods for table "stock_prediction"
type StockPredictionTable struct {
	h SQLHandle
}

func (t *StockPredictionTable) Find(ctx context.Context, filter StockPredictionValues) (StockPredictionRows, error) {
	return FindStockPredictionRows(ctx, t.h, filter)
}

func (t *StockPredictionTable) Count(ctx context.Context, filter StockPredictionValues) (int, error) {
	return CountStockPredictionRows(ctx, t.h, filter)
}

func (t *StockPredictionTable) Update(ctx context.Context, changeset, filter StockPredictionValues) (int64, error) {
	return UpdateStockPredictionRows(ctx, t.h, changeset, filter)
}

func (t *StockPredictionTable) Insert(ctx context.Context, rows ...*StockPredictionRow) (int, error) {
	return InsertReturningStockPredictionRows(ctx, t.h, rows...)
}

func (t *StockPredictionTable) Delete(ctx context.Context, filter StockPredictionValues) (int64, error) {
	return DeleteStockPredictionRows(ctx, t.h, filter)
}

func (t *StockPredictionTable) Save(ctx context.Context, rows ...*StockPredictionRow) error {
	return SaveReturningStockPredictionRows(ctx, t.h, rows...)
}

func (t *StockPredictionTable) GetByID(ctx context.Context, keys ...interface{}) (StockPredictionRows, error) {
	return GetStockPredictionRowsByID(ctx, t.h, keys...)
}

func (t *StockPredictionTable) UpdateByID(ctx context.Context, changeset StockPredictionValues, keys ...interface{}) (int64, error) {
	return UpdateStockPredictionRowsByID(ctx, t.h, changeset, keys...)
}

func (t *StockPredictionTable) DeleteByID(ctx context.Context, keys ...interface{}) (int64, error) {
	return DeleteStockPredictionRowsByID(ctx, t.h, keys...)
}

type StockPredictionValues struct {
	ID          *string    `json:"id"`
	StartDate   *time.Time `json:"start_date"`
	EndDate     *time.Time `json:"end_date"`
	StockCode   *string    `json:"stock_code"`
	Created     *time.Time `json:"created"`
	RequesterID *string    `json:"requester_id"`
}

// InsertStockPredictionRows inserts the rows into table "stock_prediction"
func InsertStockPredictionRows(ctx context.Context, db SQLHandle, rows ...*StockPredictionRow) (numRows int64, err error) {
	if len(rows) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertStockPredictionRows, rows)
	if err != nil {
		return numRows, formatError("InsertStockPredictionRows", err)
	}
	return numRows, nil
}

// InsertReturningStockPredictionRows inserts the rows into table "stock_prediction" and returns the rows.
func InsertReturningStockPredictionRows(ctx context.Context, db SQLHandle, inputs ...*StockPredictionRow) (numRows int, err error) {
	if len(inputs) == 0 {
		return 0, nil
	}
	rows := StockPredictionRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningStockPredictionRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningStockPredictionRows", err)
	}
	return numRows, nil
}

// FindStockPredictionRows finds the rows matching the condition from table "stock_prediction"
func FindStockPredictionRows(ctx context.Context, db SQLHandle, cond StockPredictionValues) (rows StockPredictionRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindStockPredictionRows, cond); err != nil {
		return nil, formatError("FindStockPredictionRows", err)
	}
	return rows, nil
}

// DeleteStockPredictionRows deletes the rows matching the condition from table "stock_prediction"
func DeleteStockPredictionRows(ctx context.Context, db SQLHandle, cond StockPredictionValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeleteStockPredictionRows, cond); err != nil {
		return numRows, formatError("DeleteStockPredictionRows", err)
	}
	return numRows, nil
}

func UpdateStockPredictionRows(ctx context.Context, db SQLHandle, changeset, filter StockPredictionValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdateStockPredictionRows, changeset, filter); err != nil {
		return numRows, formatError("UpdateStockPredictionRows", err)
	}
	return numRows, nil
}

// CountStockPredictionRows counts the number of rows matching the condition from table "stock_prediction"
func CountStockPredictionRows(ctx context.Context, db SQLHandle, cond StockPredictionValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountStockPredictionRows, cond); err != nil {
		return 0, formatError("CountStockPredictionRows", err)
	}
	return count, nil
}

// SaveStockPredictionRows upserts the given rows for table "stock_prediction" checking uniqueness by contstraint "stock_prediction_pkey"
func SaveStockPredictionRows(ctx context.Context, db SQLHandle, rows ...*StockPredictionRow) (err error) {
	if len(rows) == 0 {
		return nil
	}
	_, err = execWithJSONArgs(ctx, db, SQLSaveStockPredictionRows, rows)
	if err != nil {
		return formatError("SaveStockPredictionRows", err)
	}
	return nil
}

// SaveReturningStockPredictionRows upserts the given rows for table "stock_prediction" checking uniqueness by contstraint "stock_prediction_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningStockPredictionRows(ctx context.Context, db SQLHandle, inputs ...*StockPredictionRow) (err error) {
	if len(inputs) == 0 {
		return nil
	}
	rows := StockPredictionRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningStockPredictionRows, rows)
	if err != nil {
		return formatError("SaveReturningStockPredictionRows", err)
	}
	return nil
}

// GetStockPredictionRowsByID gets matching rows for given ID keys from table "stock_prediction"
func GetStockPredictionRowsByID(ctx context.Context, db SQLHandle, keys ...interface{}) (rows StockPredictionRows, err error) {
	if len(keys) == 0 {
		return nil, nil
	}
	rows = make(StockPredictionRows, 0, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLGetStockPredictionRowsByID, Keys(keys)); err != nil {
		return nil, formatError("GetStockPredictionRowsByID", err)
	}
	return rows, nil
}

// DeleteStockPredictionRowsByID deletes matching rows by StockPredictionID keys from table "stock_prediction"
func DeleteStockPredictionRowsByID(ctx context.Context, db SQLHandle, keys ...interface{}) (numRows int64, err error) {
	if len(keys) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLDeleteStockPredictionRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteStockPredictionRowsByID", err)
	}
	return numRows, nil
}

// UpdateStockPredictionRowsByID deletes matching rows by StockPredictionID keys from table "stock_prediction"
func UpdateStockPredictionRowsByID(ctx context.Context, db SQLHandle, changeset StockPredictionValues, keys ...interface{}) (numRows int64, err error) {
	if len(keys) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdateStockPredictionRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateStockPredictionRowsByID", err)
	}
	return numRows, nil
}

// ReceiveRow returns all pointers of the column values for scanning
func (r *StockPredictionRow) ReceiveRow() []interface{} {
	return []interface{}{&r.StockPredictionData.ID, &r.StockPredictionData.StartDate, &r.StockPredictionData.EndDate, &r.StockPredictionData.StockCode, &r.StockPredictionData.Created, &r.StockPredictionData.RequesterID}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *StockPredictionRows) ReceiveRows(i int) []interface{} {
	if len(*rs) <= i {
		*rs = append(*rs, new(StockPredictionRow))
	} else if (*rs)[i] == nil {
		(*rs)[i] = new(StockPredictionRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *StockPredictionRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.StockPredictionData)
}

var (
	SQLFindStockPredictionRows = `
		WITH __f AS (SELECT "id", "start_date", "end_date", "stock_code", "created", "requester_id" FROM json_populate_record(null::"gh"."stock_prediction", $1))
		SELECT __t.id, __t.start_date, __t.end_date, __t.stock_code, __t.created, __t.requester_id
		FROM "gh"."stock_prediction" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."start_date" IS NULL FROM __f) OR (SELECT __f."start_date" = __t."start_date" FROM __f))
			AND ((SELECT __f."end_date" IS NULL FROM __f) OR (SELECT __f."end_date" = __t."end_date" FROM __f))
			AND ((SELECT __f."stock_code" IS NULL FROM __f) OR (SELECT __f."stock_code" = __t."stock_code" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."requester_id" IS NULL FROM __f) OR (SELECT __f."requester_id" = __t."requester_id" FROM __f))`
	SQLCountStockPredictionRows = `
		WITH __f AS (SELECT "id", "start_date", "end_date", "stock_code", "created", "requester_id" FROM json_populate_record(null::"gh"."stock_prediction", $1))
		SELECT count(*) FROM "gh"."stock_prediction" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."start_date" IS NULL FROM __f) OR (SELECT __f."start_date" = __t."start_date" FROM __f))
			AND ((SELECT __f."end_date" IS NULL FROM __f) OR (SELECT __f."end_date" = __t."end_date" FROM __f))
			AND ((SELECT __f."stock_code" IS NULL FROM __f) OR (SELECT __f."stock_code" = __t."stock_code" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."requester_id" IS NULL FROM __f) OR (SELECT __f."requester_id" = __t."requester_id" FROM __f))`
	SQLReturningStockPredictionRows = `
		RETURNING "id", "start_date", "end_date", "stock_code", "created", "requester_id"`
	SQLInsertStockPredictionRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."stock_prediction", $1))
		INSERT INTO "gh"."stock_prediction" AS __t ("id", "start_date", "end_date", "stock_code", "created", "requester_id")
		SELECT 
			__v."id", 
			__v."start_date", 
			__v."end_date", 
			__v."stock_code", 
			__v."created", 
			__v."requester_id" FROM __v`
	SQLInsertReturningStockPredictionRows = SQLInsertStockPredictionRows + SQLReturningStockPredictionRows
	SQLDeleteStockPredictionRows          = `
		DELETE FROM "gh"."stock_prediction" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'start_date' IS NULL) OR CAST($1::json->>'start_date' AS date) = __t."start_date")
			AND (($1::json->>'end_date' IS NULL) OR CAST($1::json->>'end_date' AS date) = __t."end_date")
			AND (($1::json->>'stock_code' IS NULL) OR CAST($1::json->>'stock_code' AS character varying) = __t."stock_code")
			AND (($1::json->>'created' IS NULL) OR CAST($1::json->>'created' AS timestamp with time zone) = __t."created")
			AND (($1::json->>'requester_id' IS NULL) OR CAST($1::json->>'requester_id' AS uuid) = __t."requester_id")`
	SQLDeleteReturningStockPredictionRows = SQLDeleteStockPredictionRows + SQLReturningStockPredictionRows
	SQLUpdateStockPredictionRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"gh"."stock_prediction", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"gh"."stock_prediction", $2))
		UPDATE "gh"."stock_prediction" AS __t
		SET ("id", "start_date", "end_date", "stock_code", "created", "requester_id") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."start_date", __t."start_date"), 
			COALESCE(__v."end_date", __t."end_date"), 
			COALESCE(__v."stock_code", __t."stock_code"), 
			COALESCE(__v."created", __t."created"), 
			COALESCE(__v."requester_id", __t."requester_id") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."start_date" IS NULL FROM __f) OR (SELECT __f."start_date" = __t."start_date" FROM __f))
			AND ((SELECT __f."end_date" IS NULL FROM __f) OR (SELECT __f."end_date" = __t."end_date" FROM __f))
			AND ((SELECT __f."stock_code" IS NULL FROM __f) OR (SELECT __f."stock_code" = __t."stock_code" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."requester_id" IS NULL FROM __f) OR (SELECT __f."requester_id" = __t."requester_id" FROM __f))`
	SQLUpdateReturningStockPredictionRows = SQLUpdateStockPredictionRows + SQLReturningStockPredictionRows
	SQLReplaceStockPredictionRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."stock_prediction", $1))
		UPDATE "gh"."stock_prediction" AS __t
			SET ("id", "start_date", "end_date", "stock_code", "created", "requester_id") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."start_date", __t."start_date"), 
				COALESCE(__v."end_date", __t."end_date"), 
				COALESCE(__v."stock_code", __t."stock_code"), 
				COALESCE(__v."created", __t."created"), 
				COALESCE(__v."requester_id", __t."requester_id")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	SQLReplaceReturningStockPredictionRows = SQLReplaceStockPredictionRows + SQLReturningStockPredictionRows
	SQLSaveStockPredictionRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."stock_prediction", $1))
		INSERT INTO "gh"."stock_prediction" AS __t ("id", "start_date", "end_date", "stock_code", "created", "requester_id")
		SELECT 
			__v."id", 
			__v."start_date", 
			__v."end_date", 
			__v."stock_code", 
			__v."created", 
			__v."requester_id" FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "start_date", "end_date", "stock_code", "created", "requester_id") = (
			SELECT "id", "start_date", "end_date", "stock_code", "created", "requester_id" FROM __v
			WHERE __v."id" = __t."id"
		)`
	SQLSaveReturningStockPredictionRows = SQLSaveStockPredictionRows + SQLReturningStockPredictionRows
	SQLGetStockPredictionRowsByID       = `
		WITH __key AS (SELECT DISTINCT "id" FROM json_populate_recordset(null::"gh"."stock_prediction", $1))
		SELECT "id", "start_date", "end_date", "stock_code", "created", "requester_id"
		FROM __key JOIN "gh"."stock_prediction" AS __t USING ("id")`
	SQLUpdateStockPredictionRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"gh"."stock_prediction", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"gh"."stock_prediction", $2))
		UPDATE "gh"."stock_prediction" AS __t
		SET ("id", "start_date", "end_date", "stock_code", "created", "requester_id") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."start_date", __t."start_date"), 
			COALESCE(__v."end_date", __t."end_date"), 
			COALESCE(__v."stock_code", __t."stock_code"), 
			COALESCE(__v."created", __t."created"), 
			COALESCE(__v."requester_id", __t."requester_id")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	SQLDeleteStockPredictionRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"gh"."stock_prediction", $1))
		DELETE FROM "gh"."stock_prediction" AS __t USING __key WHERE (__key."id" = __t."id")`
	SQLDeleteReturningStockPredictionRowsByID = SQLDeleteStockPredictionRowsByID + SQLReturningStockPredictionRows
)
