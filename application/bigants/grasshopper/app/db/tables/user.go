// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
	"time"
)

// UserRow represents a row for table "user"
type UserRow struct {
	UserData
}

type UserData struct {
	ID       string    `json:"id"`
	Created  time.Time `json:"created"`
	Password string    `json:"password"`
}

func NewUserRow(id string, created time.Time, password string) *UserRow {
	return &UserRow{UserData{id, created, password}}
}

func NewUserRows(data ...UserData) UserRows {
	rows := make(UserRows, len(data))
	for i, d := range data {
		rows[i] = &UserRow{d}
	}
	return rows
}

// GetID gets value of column "id" from "user" row
func (r *UserRow) GetID() string { return r.UserData.ID }

// SetID sets value of column "id" in "user" row
func (r *UserRow) SetID(id string) { r.UserData.ID = id }

// GetCreated gets value of column "created" from "user" row
func (r *UserRow) GetCreated() time.Time { return r.UserData.Created }

// SetCreated sets value of column "created" in "user" row
func (r *UserRow) SetCreated(created time.Time) { r.UserData.Created = created }

// GetPassword gets value of column "password" from "user" row
func (r *UserRow) GetPassword() string { return r.UserData.Password }

// SetPassword sets value of column "password" in "user" row
func (r *UserRow) SetPassword(password string) { r.UserData.Password = password }

// UserID represents key defined by PRIMARY KEY constraint "user_pkey" for table "user"
type UserID struct {
	ID string `json:"id"`
}

func (r *UserRow) KeyID() UserID {
	return UserID{r.GetID()}
}

// UserRows represents multiple rows for table "user"
type UserRows []*UserRow

func (rs UserRows) KeyID() (keys Keys) {
	keys = make(Keys, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyID()
	}
	return keys
}

// NewUserTable(h SQLHandle) creates new UserTable
func NewUserTable(h SQLHandle) *UserTable {
	return &UserTable{h}
}

// UserTable provides access methods for table "user"
type UserTable struct {
	h SQLHandle
}

func (t *UserTable) Find(ctx context.Context, filter UserValues) (UserRows, error) {
	return FindUserRows(ctx, t.h, filter)
}

func (t *UserTable) Count(ctx context.Context, filter UserValues) (int, error) {
	return CountUserRows(ctx, t.h, filter)
}

func (t *UserTable) Update(ctx context.Context, changeset, filter UserValues) (int64, error) {
	return UpdateUserRows(ctx, t.h, changeset, filter)
}

func (t *UserTable) Insert(ctx context.Context, rows ...*UserRow) (int, error) {
	return InsertReturningUserRows(ctx, t.h, rows...)
}

func (t *UserTable) Delete(ctx context.Context, filter UserValues) (int64, error) {
	return DeleteUserRows(ctx, t.h, filter)
}

func (t *UserTable) Save(ctx context.Context, rows ...*UserRow) error {
	return SaveReturningUserRows(ctx, t.h, rows...)
}

func (t *UserTable) GetByID(ctx context.Context, keys ...interface{}) (UserRows, error) {
	return GetUserRowsByID(ctx, t.h, keys...)
}

func (t *UserTable) UpdateByID(ctx context.Context, changeset UserValues, keys ...interface{}) (int64, error) {
	return UpdateUserRowsByID(ctx, t.h, changeset, keys...)
}

func (t *UserTable) DeleteByID(ctx context.Context, keys ...interface{}) (int64, error) {
	return DeleteUserRowsByID(ctx, t.h, keys...)
}

type UserValues struct {
	ID       *string    `json:"id"`
	Created  *time.Time `json:"created"`
	Password *string    `json:"password"`
}

// InsertUserRows inserts the rows into table "user"
func InsertUserRows(ctx context.Context, db SQLHandle, rows ...*UserRow) (numRows int64, err error) {
	if len(rows) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertUserRows, rows)
	if err != nil {
		return numRows, formatError("InsertUserRows", err)
	}
	return numRows, nil
}

// InsertReturningUserRows inserts the rows into table "user" and returns the rows.
func InsertReturningUserRows(ctx context.Context, db SQLHandle, inputs ...*UserRow) (numRows int, err error) {
	if len(inputs) == 0 {
		return 0, nil
	}
	rows := UserRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningUserRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningUserRows", err)
	}
	return numRows, nil
}

// FindUserRows finds the rows matching the condition from table "user"
func FindUserRows(ctx context.Context, db SQLHandle, cond UserValues) (rows UserRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindUserRows, cond); err != nil {
		return nil, formatError("FindUserRows", err)
	}
	return rows, nil
}

// DeleteUserRows deletes the rows matching the condition from table "user"
func DeleteUserRows(ctx context.Context, db SQLHandle, cond UserValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeleteUserRows, cond); err != nil {
		return numRows, formatError("DeleteUserRows", err)
	}
	return numRows, nil
}

func UpdateUserRows(ctx context.Context, db SQLHandle, changeset, filter UserValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdateUserRows, changeset, filter); err != nil {
		return numRows, formatError("UpdateUserRows", err)
	}
	return numRows, nil
}

// CountUserRows counts the number of rows matching the condition from table "user"
func CountUserRows(ctx context.Context, db SQLHandle, cond UserValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountUserRows, cond); err != nil {
		return 0, formatError("CountUserRows", err)
	}
	return count, nil
}

// SaveUserRows upserts the given rows for table "user" checking uniqueness by contstraint "user_pkey"
func SaveUserRows(ctx context.Context, db SQLHandle, rows ...*UserRow) (err error) {
	if len(rows) == 0 {
		return nil
	}
	_, err = execWithJSONArgs(ctx, db, SQLSaveUserRows, rows)
	if err != nil {
		return formatError("SaveUserRows", err)
	}
	return nil
}

// SaveReturningUserRows upserts the given rows for table "user" checking uniqueness by contstraint "user_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningUserRows(ctx context.Context, db SQLHandle, inputs ...*UserRow) (err error) {
	if len(inputs) == 0 {
		return nil
	}
	rows := UserRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningUserRows, rows)
	if err != nil {
		return formatError("SaveReturningUserRows", err)
	}
	return nil
}

// GetUserRowsByID gets matching rows for given ID keys from table "user"
func GetUserRowsByID(ctx context.Context, db SQLHandle, keys ...interface{}) (rows UserRows, err error) {
	if len(keys) == 0 {
		return nil, nil
	}
	rows = make(UserRows, 0, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLGetUserRowsByID, Keys(keys)); err != nil {
		return nil, formatError("GetUserRowsByID", err)
	}
	return rows, nil
}

// DeleteUserRowsByID deletes matching rows by UserID keys from table "user"
func DeleteUserRowsByID(ctx context.Context, db SQLHandle, keys ...interface{}) (numRows int64, err error) {
	if len(keys) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLDeleteUserRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteUserRowsByID", err)
	}
	return numRows, nil
}

// UpdateUserRowsByID deletes matching rows by UserID keys from table "user"
func UpdateUserRowsByID(ctx context.Context, db SQLHandle, changeset UserValues, keys ...interface{}) (numRows int64, err error) {
	if len(keys) == 0 {
		return 0, nil
	}
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdateUserRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateUserRowsByID", err)
	}
	return numRows, nil
}

// ReceiveRow returns all pointers of the column values for scanning
func (r *UserRow) ReceiveRow() []interface{} {
	return []interface{}{&r.UserData.ID, &r.UserData.Created, &r.UserData.Password}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *UserRows) ReceiveRows(i int) []interface{} {
	if len(*rs) <= i {
		*rs = append(*rs, new(UserRow))
	} else if (*rs)[i] == nil {
		(*rs)[i] = new(UserRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *UserRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.UserData)
}

var (
	SQLFindUserRows = `
		WITH __f AS (SELECT "id", "created", "password" FROM json_populate_record(null::"gh"."user", $1))
		SELECT __t.id, __t.created, __t.password
		FROM "gh"."user" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."password" IS NULL FROM __f) OR (SELECT __f."password" = __t."password" FROM __f))`
	SQLCountUserRows = `
		WITH __f AS (SELECT "id", "created", "password" FROM json_populate_record(null::"gh"."user", $1))
		SELECT count(*) FROM "gh"."user" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."password" IS NULL FROM __f) OR (SELECT __f."password" = __t."password" FROM __f))`
	SQLReturningUserRows = `
		RETURNING "id", "created", "password"`
	SQLInsertUserRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."user", $1))
		INSERT INTO "gh"."user" AS __t ("id", "created", "password")
		SELECT 
			__v."id", 
			__v."created", 
			__v."password" FROM __v`
	SQLInsertReturningUserRows = SQLInsertUserRows + SQLReturningUserRows
	SQLDeleteUserRows          = `
		DELETE FROM "gh"."user" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'created' IS NULL) OR CAST($1::json->>'created' AS timestamp with time zone) = __t."created")
			AND (($1::json->>'password' IS NULL) OR CAST($1::json->>'password' AS character varying) = __t."password")`
	SQLDeleteReturningUserRows = SQLDeleteUserRows + SQLReturningUserRows
	SQLUpdateUserRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"gh"."user", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"gh"."user", $2))
		UPDATE "gh"."user" AS __t
		SET ("id", "created", "password") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."created", __t."created"), 
			COALESCE(__v."password", __t."password") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."created" IS NULL FROM __f) OR (SELECT __f."created" = __t."created" FROM __f))
			AND ((SELECT __f."password" IS NULL FROM __f) OR (SELECT __f."password" = __t."password" FROM __f))`
	SQLUpdateReturningUserRows = SQLUpdateUserRows + SQLReturningUserRows
	SQLReplaceUserRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."user", $1))
		UPDATE "gh"."user" AS __t
			SET ("id", "created", "password") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."created", __t."created"), 
				COALESCE(__v."password", __t."password")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	SQLReplaceReturningUserRows = SQLReplaceUserRows + SQLReturningUserRows
	SQLSaveUserRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"gh"."user", $1))
		INSERT INTO "gh"."user" AS __t ("id", "created", "password")
		SELECT 
			__v."id", 
			__v."created", 
			__v."password" FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "created", "password") = (
			SELECT "id", "created", "password" FROM __v
			WHERE __v."id" = __t."id"
		)`
	SQLSaveReturningUserRows = SQLSaveUserRows + SQLReturningUserRows
	SQLGetUserRowsByID       = `
		WITH __key AS (SELECT DISTINCT "id" FROM json_populate_recordset(null::"gh"."user", $1))
		SELECT "id", "created", "password"
		FROM __key JOIN "gh"."user" AS __t USING ("id")`
	SQLUpdateUserRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"gh"."user", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"gh"."user", $2))
		UPDATE "gh"."user" AS __t
		SET ("id", "created", "password") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."created", __t."created"), 
			COALESCE(__v."password", __t."password")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	SQLDeleteUserRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"gh"."user", $1))
		DELETE FROM "gh"."user" AS __t USING __key WHERE (__key."id" = __t."id")`
	SQLDeleteReturningUserRowsByID = SQLDeleteUserRowsByID + SQLReturningUserRows
)
